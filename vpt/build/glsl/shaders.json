{"ArtisticToneMapper":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + 1.0) * 0.5;\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n#define M_PI 3.1415926535897932384626\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uLow;\r\nuniform float uMid;\r\nuniform float uHigh;\r\nuniform float uSaturation;\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 color = texture(uTexture, vFragmentPosition);\r\n    color = (color - uLow) / (uHigh - uLow);\r\n    const vec3 gray = normalize(vec3(1));\r\n    color = vec4(mix(dot(color.rgb, gray) * gray, color.rgb, uSaturation), 1.0);\r\n    float midpoint = (uMid - uLow) / (uHigh - uLow);\r\n    float exponent = -log(2.0) / log(midpoint);\r\n    color = pow(color, vec4(exponent));\r\n    oColor = vec4(color.rgb, 1.0);\r\n}"},"ExposureToneMapper":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 color;\r\n\r\nconst float gamma = 2.2;\r\n\r\nvoid main() {\r\n    vec4 rgba = texture(uTexture, vFragmentPosition);\r\n    vec4 mapped = vec4(1.0) - exp(-rgb * uExposure);\r\n    mapped = pow(mapped, 1.0 / gamma);\r\n    color = vec4(mapped.rgb, 1.0);\r\n}"},"RangeToneMapper":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uMin;\r\nuniform float uMax;\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 color;\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vFragmentPosition);\r\n    color = (src - uMin) / (uMax - uMin);\r\n}"},"ReinhardToneMapper":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 color;\r\n\r\n@XYZITU2002\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vFragmentPosition);\r\n    vec3 xyY = xyz2xyY(rgb2xyz(src.rgb));\r\n    xyY.z /= 1.0 / uExposure + xyY.z;\r\n    color = vec4(xyz2rgb(xyY2xyz(xyY)), 1.0);\r\n}"},"EAMGenerate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\n\r\n@unproject\r\n\r\nvoid main() {\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform float uStepSize;\r\nuniform float uOffset;\r\nuniform float uAlphaCorrection;\r\n\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\nout vec4 oColor;\r\n\r\n@intersectCube\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n    if (tbounds.x >= tbounds.y) {\r\n        oColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    } else {\r\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\r\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\r\n        float rayStepLength = distance(from, to) * uStepSize;\r\n\r\n        float t = 0.0;\r\n        vec3 pos;\r\n        float val;\r\n        vec4 colorSample;\r\n        vec4 accumulator = vec4(0.0);\r\n\r\n        while (t < 1.0 && accumulator.a < 0.99) {\r\n            pos = mix(from, to, t);\r\n            val = texture(uVolume, pos).r;\r\n            colorSample = texture(uTransferFunction, vec2(val, 0.5));\r\n            colorSample.a *= rayStepLength * uAlphaCorrection;\r\n            colorSample.rgb *= colorSample.a;\r\n            accumulator += (1.0 - accumulator.a) * colorSample;\r\n            t += uStepSize;\r\n        }\r\n\r\n        if (accumulator.a > 1.0) {\r\n            accumulator.rgb /= accumulator.a;\r\n        }\r\n\r\n        oColor = vec4(accumulator.rgb, 1.0);\r\n    }\r\n}\r\n\r\n//"},"EAMIntegrate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = texture(uFrame, vPosition);\r\n}\r\n\r\n//"},"EAMRender":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = texture(uAccumulator, vPosition);\r\n}\r\n\r\n//"},"EAMReset":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n}"},"ISOGenerate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\n\r\n@unproject\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uClosest;\r\nuniform mediump sampler3D uVolume;\r\nuniform float uStepSize;\r\nuniform float uOffset;\r\nuniform float uIsovalue;\r\n\r\nin vec2 vPosition;\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\n\r\nout vec4 oClosest;\r\n\r\n@intersectCube\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n    if (tbounds.x >= tbounds.y) {\r\n        oClosest = vec4(-1);\r\n    } else {\r\n        vec4 from = vec4(mix(vRayFrom, vRayTo, tbounds.x), tbounds.x);\r\n        vec4 to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\r\n\r\n        float closest = texture(uClosest, vPosition).w;\r\n        if (closest > 0.0) {\r\n            tbounds.y = closest;\r\n        }\r\n\r\n        float t = 0.0;\r\n        float offset = uOffset;\r\n        vec3 pos;\r\n        float value;\r\n        bool found = false;\r\n        do {\r\n            pos = mix(from.xyz, to.xyz, offset);\r\n            value = texture(uVolume, pos).r;\r\n            if (value >= uIsovalue) {\r\n                tbounds.y = mix(from.w, to.w, offset);\r\n                to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\r\n                found = true;\r\n            }\r\n            t += uStepSize;\r\n            offset = mod(offset + uStepSize + uOffset, 1.0);\r\n        } while (t < 1.0);\r\n\r\n        if (found) {\r\n            oClosest = to;\r\n        } else {\r\n            oClosest = vec4(-1);\r\n        }\r\n    }\r\n}\r\n\r\n//"},"ISOIntegrate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\n\r\nout vec4 oClosest;\r\n\r\nvoid main() {\r\n    vec4 frame = texture(uFrame, vPosition);\r\n    vec4 acc = texture(uAccumulator, vPosition);\r\n    if (frame.w > 0.0 && acc.w > 0.0) {\r\n        oClosest = frame.w < acc.w ? frame : acc;\r\n    } else if (frame.w > 0.0) {\r\n        oClosest = frame;\r\n    } else {\r\n        oClosest = acc;\r\n    }\r\n}\r\n\r\n//"},"ISORender":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uClosest;\r\nuniform mediump sampler3D uVolume;\r\nuniform vec3 uLight;\r\nuniform vec3 uDiffuse;\r\n\r\nin vec2 vPosition;\r\n\r\nout vec4 oColor;\r\n\r\nvec3 gradient(vec3 pos, float h) {\r\n    vec3 positive = vec3(\r\n        texture(uVolume, pos + vec3( h, 0.0, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0,  h, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, 0.0,  h)).r\r\n    );\r\n    vec3 negative = vec3(\r\n        texture(uVolume, pos + vec3(-h, 0.0, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, -h, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, 0.0, -h)).r\r\n    );\r\n    return normalize(positive - negative);\r\n}\r\n\r\nvoid main() {\r\n    vec4 closest = texture(uClosest, vPosition);\r\n\r\n    if (closest.w > 0.0) {\r\n        vec3 normal = normalize(gradient(closest.xyz, 0.005));\r\n        vec3 light = normalize(uLight);\r\n        float lambert = max(dot(normal, light), 0.0);\r\n        oColor = vec4(uDiffuse * lambert, 1.0);\r\n    } else {\r\n        oColor = vec4(1.0);\r\n    }\r\n}\r\n\r\n//"},"ISOReset":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oClosest;\r\n\r\nvoid main() {\r\n    oClosest = vec4(-1);\r\n}"},"MCCRender":{"compute":"#version 310 es\r\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\r\n\r\n#define M_INVPI 0.31830988618\r\n#define M_2PI 6.28318530718\r\n#define EPS 1e-5\r\n\r\n@Photon\r\n\r\nlayout (std430, binding = 0) buffer bPhotons {\r\n    Photon sPhotons[];\r\n};\r\n\r\nlayout (rgba32f, binding = 0) restrict writeonly highp uniform image2D oRadiance;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform mediump sampler2D uEnvironment;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\nuniform float uAbsorptionCoefficient;\r\nuniform float uScatteringCoefficient;\r\nuniform float uScatteringBias;\r\nuniform float uMajorant;\r\nuniform uint uMaxBounces;\r\nuniform uint uSteps;\r\n\r\n@rand\r\n@unprojectRand\r\n@intersectCube\r\n\r\nvoid resetPhoton(inout vec2 randState, inout Photon photon) {\r\n    vec3 from, to;\r\n    vec2 screen = vec2(gl_GlobalInvocationID.xy) * uInverseResolution * 2.0 - 1.0;\r\n    unprojectRand(randState, screen, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    photon.bounces = 0u;\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n}\r\n\r\nvec4 sampleEnvironmentMap(vec3 d) {\r\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\r\n    return texture(uEnvironment, texCoord);\r\n}\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nvec3 randomDirection(vec2 U) {\r\n    float phi = U.x * M_2PI;\r\n    float z = U.y * 2.0 - 1.0;\r\n    float k = sqrt(1.0 - z * z);\r\n    return vec3(k * cos(phi), k * sin(phi), z);\r\n}\r\n\r\nfloat sampleHenyeyGreensteinAngleCosine(float g, float U) {\r\n    float g2 = g * g;\r\n    float c = (1.0 - g2) / (1.0 - g + 2.0 * g * U);\r\n    return (1.0 + g2 - c * c) / (2.0 * g);\r\n}\r\n\r\nvec3 sampleHenyeyGreenstein(float g, vec2 U, vec3 direction) {\r\n    // generate random direction and adjust it so that the angle is HG-sampled\r\n    vec3 u = randomDirection(U);\r\n    if (abs(g) < EPS) {\r\n        return u;\r\n    }\r\n    float hgcos = sampleHenyeyGreensteinAngleCosine(g, fract(sin(U.x * 12345.6789) + 0.816723));\r\n    float lambda = hgcos - dot(direction, u);\r\n    return normalize(u + lambda * direction);\r\n}\r\n\r\nvoid main() {\r\n    uvec3 globalSize = gl_WorkGroupSize * gl_NumWorkGroups;\r\n    uint globalInvocationIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * globalSize.x;\r\n    Photon photon = sPhotons[globalInvocationIndex];\r\n\r\n    vec2 r = rand(vec2(gl_GlobalInvocationID.xy) * uRandSeed);\r\n    for (uint i = 0u; i < uSteps; i++) {\r\n        r = rand(r);\r\n        float t = -log(r.x) / uMajorant;\r\n        photon.position += t * photon.direction;\r\n\r\n        vec4 volumeSample = sampleVolumeColor(photon.position);\r\n        float muAbsorption = volumeSample.a * uAbsorptionCoefficient;\r\n        float muScattering = volumeSample.a * uScatteringCoefficient;\r\n        float muNull = uMajorant - muAbsorption - muScattering;\r\n        float muMajorant = muAbsorption + muScattering + abs(muNull);\r\n        float PNull = abs(muNull) / muMajorant;\r\n        float PAbsorption = muAbsorption / muMajorant;\r\n        float PScattering = muScattering / muMajorant;\r\n\r\n        if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {\r\n            // out of bounds\r\n            vec4 envSample = sampleEnvironmentMap(photon.direction);\r\n            vec3 radiance = photon.transmittance * envSample.rgb;\r\n            photon.samples++;\r\n            photon.radiance += (radiance - photon.radiance) / float(photon.samples);\r\n            imageStore(oRadiance, ivec2(gl_GlobalInvocationID.xy), vec4(photon.radiance, 1));\r\n            resetPhoton(r, photon);\r\n        } else if (photon.bounces >= uMaxBounces) {\r\n            // max bounces achieved -> only estimate transmittance\r\n            float weightAS = (muAbsorption + muScattering) / uMajorant;\r\n            photon.transmittance *= 1.0 - weightAS;\r\n        } else if (r.y < PAbsorption) {\r\n            // absorption\r\n            float weightA = muAbsorption / (uMajorant * PAbsorption);\r\n            photon.transmittance *= 1.0 - weightA;\r\n        } else if (r.y < PAbsorption + PScattering) {\r\n            // scattering\r\n            r = rand(r);\r\n            float weightS = muScattering / (uMajorant * PScattering);\r\n            photon.transmittance *= volumeSample.rgb * weightS;\r\n            photon.direction = sampleHenyeyGreenstein(uScatteringBias, r, photon.direction);\r\n            photon.bounces++;\r\n        } else {\r\n            // null collision\r\n            float weightN = muNull / (uMajorant * PNull);\r\n            photon.transmittance *= weightN;\r\n        }\r\n    }\r\n\r\n    sPhotons[globalInvocationIndex] = photon;\r\n}\r\n\r\n//"},"MCCReset":{"compute":"#version 310 es\r\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\n@rand\r\n@unprojectRand\r\n@intersectCube\r\n\r\n@Photon\r\n\r\nlayout (std430, binding = 0) buffer bPhotons {\r\n    Photon sPhotons[];\r\n};\r\n\r\nvoid main() {\r\n    Photon photon;\r\n    vec3 from, to;\r\n    vec2 screen = vec2(gl_GlobalInvocationID.xy) * uInverseResolution * 2.0 - 1.0;\r\n    vec2 randState = rand(screen * uRandSeed);\r\n    unprojectRand(randState, screen, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n    photon.radiance = vec3(1);\r\n    photon.bounces = 0u;\r\n    photon.samples = 0u;\r\n    uvec3 globalSize = gl_WorkGroupSize * gl_NumWorkGroups;\r\n    uint globalInvocationIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * globalSize.x;\r\n    sPhotons[globalInvocationIndex] = photon;\r\n}"},"MCMGenerate":{"vertex":"void main() {}\r\n\r\n//","fragment":"void main() {}\r\n\r\n//"},"MCMIntegrate":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n#define M_INVPI 0.31830988618\r\n#define M_2PI 6.28318530718\r\n#define EPS 1e-5\r\n\r\n@Photon\r\n\r\nuniform mediump sampler2D uPosition;\r\nuniform mediump sampler2D uDirection;\r\nuniform mediump sampler2D uTransmittance;\r\nuniform mediump sampler2D uRadiance;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform mediump sampler2D uEnvironment;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\nuniform float uAbsorptionCoefficient;\r\nuniform float uScatteringCoefficient;\r\nuniform float uScatteringBias;\r\nuniform float uMajorant;\r\nuniform uint uMaxBounces;\r\nuniform uint uSteps;\r\n\r\nin vec2 vPosition;\r\n\r\nlayout (location = 0) out vec4 oPosition;\r\nlayout (location = 1) out vec4 oDirection;\r\nlayout (location = 2) out vec4 oTransmittance;\r\nlayout (location = 3) out vec4 oRadiance;\r\n\r\n@rand\r\n@unprojectRand\r\n@intersectCube\r\n\r\nvoid resetPhoton(inout vec2 randState, inout Photon photon) {\r\n    vec3 from, to;\r\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    photon.bounces = 0u;\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n    photon.pressure = 1.0;\r\n}\r\n\r\nvec4 sampleEnvironmentMap(vec3 d) {\r\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\r\n    return texture(uEnvironment, texCoord);\r\n}\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nvec3 randomDirection(vec2 U) {\r\n    float phi = U.x * M_2PI;\r\n    float z = U.y * 2.0 - 1.0;\r\n    float k = sqrt(1.0 - z * z);\r\n    return vec3(k * cos(phi), k * sin(phi), z);\r\n}\r\n\r\nfloat sampleHenyeyGreensteinAngleCosine(float g, float U) {\r\n    float g2 = g * g;\r\n    float c = (1.0 - g2) / (1.0 - g + 2.0 * g * U);\r\n    return (1.0 + g2 - c * c) / (2.0 * g);\r\n}\r\n\r\nvec3 sampleHenyeyGreenstein(float g, vec2 U, vec3 direction) {\r\n    // generate random direction and adjust it so that the angle is HG-sampled\r\n    vec3 u = randomDirection(U);\r\n    if (abs(g) < EPS) {\r\n        return u;\r\n    }\r\n    float hgcos = sampleHenyeyGreensteinAngleCosine(g, fract(sin(U.x * 12345.6789) + 0.816723));\r\n    float lambda = hgcos - dot(direction, u);\r\n    return normalize(u + lambda * direction);\r\n}\r\n\r\nvoid main() {\r\n    Photon photon;\r\n    vec2 mappedPosition = vPosition * 0.5 + 0.5;\r\n    photon.position = texture(uPosition, mappedPosition).xyz;\r\n\r\n    vec4 directionAndBounces = texture(uDirection, mappedPosition);\r\n    photon.direction = directionAndBounces.xyz;\r\n    photon.bounces = uint(directionAndBounces.w + 0.5);\r\n\r\n    vec4 transmittanceAndPressure = texture(uTransmittance, mappedPosition);\r\n    photon.transmittance = transmittanceAndPressure.rgb;\r\n    photon.pressure = transmittanceAndPressure.w;\r\n\r\n    vec4 radianceAndSamples = texture(uRadiance, mappedPosition);\r\n    photon.radiance = radianceAndSamples.rgb;\r\n    photon.samples = uint(radianceAndSamples.w + 0.5);\r\n\r\n    vec2 r = rand(vPosition * uRandSeed);\r\n    for (uint i = 0u; i < uSteps; i++) {\r\n        r = rand(r);\r\n        float t = -log(r.x) / uMajorant;\r\n        photon.position += t * photon.direction;\r\n\r\n        // voxData: pressure, gradient x, gradient y, gradient z\r\n        vec4 volumeSample2 = texture(uVolume, photon.position);\r\n        float currentPressure = volumeSample2.r;\r\n        vec3 gradient = vec3(volumeSample2.g, volumeSample2.b, volumeSample2.a) * 0.01;\r\n\r\n        vec4 transferSample = texture(uTransferFunction, vec2(volumeSample2.r, length(gradient)));\r\n        float muAbsorption = transferSample.a * uAbsorptionCoefficient;\r\n        float muScattering = transferSample.a * uScatteringCoefficient;\r\n\r\n        float muNull = uMajorant - muAbsorption - muScattering;\r\n        float muMajorant = muAbsorption + muScattering + abs(muNull);\r\n        float PNull = abs(muNull) / muMajorant;\r\n        float PAbsorption = muAbsorption / muMajorant;\r\n        float PScattering = muScattering / muMajorant;\r\n\r\n        if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {\r\n            // out of bounds\r\n            vec4 envSample = sampleEnvironmentMap(photon.direction);\r\n            vec3 radiance = photon.transmittance * envSample.rgb;\r\n            photon.samples++;\r\n            photon.radiance += (radiance - photon.radiance) / float(photon.samples);\r\n            resetPhoton(r, photon);\r\n        } else if (photon.bounces >= uMaxBounces) {\r\n            // max bounces achieved -> only estimate transmittance\r\n            float weightAS = (muAbsorption + muScattering) / uMajorant;\r\n            photon.transmittance *= 1.0 - weightAS;\r\n            photon.pressure = currentPressure;\r\n        } else if (r.y < PAbsorption) {\r\n            // absorption\r\n            float weightA = muAbsorption / (uMajorant * PAbsorption);\r\n            photon.transmittance *= 1.0 - weightA;\r\n            photon.pressure = currentPressure;\r\n        } else if (r.y < PAbsorption + PScattering) {\r\n            // scattering\r\n            r = rand(r);\r\n            float weightS = muScattering / (uMajorant * PScattering);\r\n            // photon.transmittance *= volumeSample.rgb * weightS;\r\n            photon.transmittance *= transferSample.rgb * weightS;\r\n\r\n            vec3 I = normalize(photon.direction);\r\n            vec3 N = normalize(gradient);\r\n            // source material index of refraction (IOR)' / 'destination material IOR.'\r\n            float eta = 1.0 - currentPressure / photon.pressure;\r\n            photon.direction = refract(I, N, eta);\r\n            if (abs(length(photon.direction)) < EPS) {\r\n                photon.direction = sampleHenyeyGreenstein(uScatteringBias, r, photon.direction);\r\n            }\r\n            photon.bounces++;\r\n            photon.pressure = currentPressure;\r\n        } else {\r\n            // null collision\r\n            float weightN = muNull / (uMajorant * PNull);\r\n            photon.transmittance *= weightN;\r\n            photon.pressure = currentPressure;\r\n        }\r\n    }\r\n\r\n    oPosition = vec4(photon.position, 0);\r\n    oDirection = vec4(photon.direction, float(photon.bounces));\r\n    oTransmittance = vec4(photon.transmittance, photon.pressure);\r\n    oRadiance = vec4(photon.radiance, float(photon.samples));\r\n}\r\n\r\n//"},"MCMRender":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uColor;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = vec4(texture(uColor, vPosition).rgb, 1);\r\n}\r\n\r\n//"},"MCMReset":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n@Photon\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\nin vec2 vPosition;\r\n\r\nlayout (location = 0) out vec4 oPosition;\r\nlayout (location = 1) out vec4 oDirection;\r\nlayout (location = 2) out vec4 oTransmittance;\r\nlayout (location = 3) out vec4 oRadiance;\r\n\r\n@rand\r\n@unprojectRand\r\n@intersectCube\r\n\r\nvoid main() {\r\n    Photon photon;\r\n    vec3 from, to;\r\n    vec2 randState = rand(vPosition * uRandSeed);\r\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n    photon.radiance = vec3(1);\r\n    photon.bounces = 0u;\r\n    photon.samples = 0u;\r\n    photon.pressure = 1.0;\r\n    oPosition = vec4(photon.position, 0);\r\n    oDirection = vec4(photon.direction, float(photon.bounces));\r\n    oTransmittance = vec4(photon.transmittance, photon.pressure);\r\n    oRadiance = vec4(photon.radiance, float(photon.samples));\r\n}"},"MCSGenerate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\nout vec2 vPosition;\r\n\r\n@unproject\r\n\r\nvoid main() {\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n#define M_INVPI 0.31830988618\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform mediump sampler2D uEnvironment;\r\nuniform float uOffset;\r\nuniform float uSigmaMax;\r\nuniform float uAlphaCorrection;\r\nuniform vec3 uScatteringDirection;\r\n\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\n@intersectCube\r\n\r\nvec2 rand(vec2 p) {\r\n    const mat2 M = mat2(\r\n        23.14069263277926, 2.665144142690225,\r\n        12.98987893203892, 78.23376739376591);\r\n    const vec2 D = vec2(\r\n        12345.6789,\r\n        43758.5453);\r\n    vec2 dotted = M * p;\r\n    vec2 mapped = vec2(cos(dotted.x), sin(dotted.y));\r\n    return fract(mapped * D);\r\n}\r\n\r\nvec4 sampleEnvironmentMap(vec3 d) {\r\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\r\n    return texture(uEnvironment, texCoord);\r\n}\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nfloat sampleDistance(vec3 from, vec3 to, inout vec2 seed) {\r\n    float maxDistance = distance(from, to);\r\n    float dist = 0.0;\r\n    float invSigmaMax = 1.0 / uSigmaMax;\r\n    float invMaxDistance = 1.0 / maxDistance;\r\n\r\n    do {\r\n        seed = rand(seed);\r\n        dist -= log(1.0 - seed.x) * invSigmaMax;\r\n        if (dist > maxDistance) {\r\n            break;\r\n        }\r\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\r\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\r\n        float alphaSample = transferSample.a * uAlphaCorrection;\r\n        if (seed.y < alphaSample * invSigmaMax) {\r\n            break;\r\n        }\r\n    } while (true);\r\n\r\n    return dist;\r\n}\r\n\r\nfloat sampleTransmittance(vec3 from, vec3 to, inout vec2 seed) {\r\n    float maxDistance = distance(from, to);\r\n    float dist = 0.0;\r\n    float invSigmaMax = 1.0 / uSigmaMax;\r\n    float invMaxDistance = 1.0 / maxDistance;\r\n    float transmittance = 1.0;\r\n\r\n    do {\r\n        seed = rand(seed);\r\n        dist -= log(1.0 - seed.x) * invSigmaMax;\r\n        if (dist > maxDistance) {\r\n            break;\r\n        }\r\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\r\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\r\n        float alphaSample = transferSample.a * uAlphaCorrection;\r\n        transmittance *= 1.0 - alphaSample * invSigmaMax;\r\n    } while (true);\r\n\r\n    return transmittance;\r\n}\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec3 rayDirectionUnit = normalize(rayDirection);\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n\r\n    if (tbounds.x >= tbounds.y) {\r\n        oColor = sampleEnvironmentMap(rayDirectionUnit);\r\n    } else {\r\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\r\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\r\n        float maxDistance = distance(from, to);\r\n\r\n        vec2 seed = vPosition + rand(vec2(uOffset, uOffset));\r\n        float dist = sampleDistance(from, to, seed);\r\n\r\n        if (dist > maxDistance) {\r\n            oColor = sampleEnvironmentMap(rayDirectionUnit);\r\n        } else {\r\n            from = mix(from, to, dist / maxDistance);\r\n            tbounds = max(intersectCube(from, uScatteringDirection), 0.0);\r\n            to = from + uScatteringDirection * tbounds.y;\r\n            vec4 diffuseColor = sampleVolumeColor(from);\r\n            vec4 lightColor = sampleEnvironmentMap(uScatteringDirection);\r\n            float transmittance = sampleTransmittance(from, to, seed);\r\n\r\n            oColor = diffuseColor * lightColor * transmittance;\r\n        }\r\n    }\r\n}\r\n\r\n//"},"MCSIntegrate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\nuniform float uInvFrameNumber;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 acc = texture(uAccumulator, vPosition);\r\n    vec4 frame = texture(uFrame, vPosition);\r\n    oColor = acc + (frame - acc) * uInvFrameNumber;\r\n}\r\n\r\n//"},"MCSRender":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 acc = texture(uAccumulator, vPosition);\r\n    oColor = acc;\r\n}\r\n\r\n//"},"MCSReset":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n}"},"MIPGenerate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\n\r\n@unproject\r\n\r\nvoid main() {\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform float uStepSize;\r\nuniform float uOffset;\r\n\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\nout float oColor;\r\n\r\n@intersectCube\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n    if (tbounds.x >= tbounds.y) {\r\n        oColor = 0.0;\r\n    } else {\r\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\r\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\r\n\r\n        float t = 0.0;\r\n        float val = 0.0;\r\n        float offset = uOffset;\r\n        vec3 pos;\r\n        do {\r\n            pos = mix(from, to, offset);\r\n            val = max(texture(uVolume, pos).r, val);\r\n            t += uStepSize;\r\n            offset = mod(offset + uStepSize, 1.0);\r\n        } while (t < 1.0);\r\n        oColor = val;\r\n    }\r\n}\r\n\r\n//"},"MIPIntegrate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\nout float oColor;\r\n\r\nvoid main() {\r\n    float acc = texture(uAccumulator, vPosition).r;\r\n    float frame = texture(uFrame, vPosition).r;\r\n    oColor = max(acc, frame);\r\n}\r\n\r\n//"},"MIPRender":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    float acc = texture(uAccumulator, vPosition).r;\r\n    oColor = vec4(acc, acc, acc, 1.0);\r\n}\r\n\r\n//"},"MIPReset":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout float oColor;\r\n\r\nvoid main() {\r\n    oColor = 0.0;\r\n}"},"average":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTextureAccumulator;\r\nuniform mediump sampler2D uTextureNew;\r\nuniform float uInvn; // inverse number of samples\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 color;\r\n\r\nvoid main() {\r\n    vec4 a = texture(uTextureAccumulator, vFragmentPosition);\r\n    vec4 b = texture(uTextureNew, vFragmentPosition);\r\n    color = a + (b - a) * uInvn;\r\n}"},"drawTransferFunction":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform vec2 uPosition;\r\nuniform vec2 uSize;\r\nuniform vec4 uColor;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    float r = length((uPosition - vPosition) / uSize);\r\n    oColor = uColor * exp(-r * r);\r\n}"},"quad":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 color;\r\n\r\nvoid main() {\r\n    color = texture(uTexture, vFragmentPosition);\r\n}"},"test":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n\r\n//","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 color;\r\n\r\nvoid main() {\r\n    color = vec4(1.0, 0.5, 0.2, 1.0);\r\n}"}}