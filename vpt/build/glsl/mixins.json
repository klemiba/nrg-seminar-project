{"XYZITU2002":"vec3 rgb2xyz(vec3 rgb) {\r\n    const mat3 RGB2XYZ = mat3(\r\n        0.412453, 0.357580, 0.180423,\r\n        0.212671, 0.715160, 0.072169,\r\n        0.019334, 0.119193, 0.950227\r\n    );\r\n\r\n    return RGB2XYZ * rgb;\r\n}\r\n\r\nvec3 xyz2rgb(vec3 xyz) {\r\n    const mat3 XYZ2RGB = mat3(\r\n         3.240481, -1.537152, -0.498536,\r\n        -0.969255,  1.875990,  0.041556,\r\n         0.055647, -0.204041,  1.057311\r\n    );\r\n\r\n    return XYZ2RGB * xyz;\r\n}\r\n\r\nvec3 xyz2xyY(vec3 xyz) {\r\n    float sum = xyz.x + xyz.y + xyz.z;\r\n    return xyz.xyy / vec3(sum, sum, 1.0);\r\n}\r\n\r\nvec3 xyY2xyz(vec3 xyY) {\r\n    return vec3(xyY.x, xyY.y, 1.0 - xyY.x - xyY.y) * xyY.z / xyY.y;\r\n}","unproject":"void unproject(in vec2 position, in mat4 inverseMvp, out vec3 from, out vec3 to) {\r\n    vec4 nearPosition = vec4(position, -1.0, 1.0);\r\n    vec4 farPosition = vec4(position, 1.0, 1.0);\r\n    vec4 fromDirty = inverseMvp * nearPosition;\r\n    vec4 toDirty = inverseMvp * farPosition;\r\n    from = fromDirty.xyz / fromDirty.w;\r\n    to = toDirty.xyz / toDirty.w;\r\n}","intersectCube":"vec2 intersectCube(in vec3 origin, in vec3 direction) {\r\n    vec3 tmin = (vec3(0.0) - origin) / direction;\r\n    vec3 tmax = (vec3(1.0) - origin) / direction;\r\n    vec3 t1 = min(tmin, tmax);\r\n    vec3 t2 = max(tmin, tmax);\r\n    float tnear = max(max(t1.x, t1.y), t1.z);\r\n    float tfar = min(min(t2.x, t2.y), t2.z);\r\n    return vec2(tnear, tfar);\r\n}","Photon":"struct Photon {\r\n    float pressure;\r\n    vec3 position;\r\n    vec3 direction;\r\n    vec3 transmittance;\r\n    vec3 radiance;\r\n    uint bounces;\r\n    uint samples;\r\n};","rand":"vec2 rand(vec2 p) {\r\n    const mat2 M = mat2(\r\n        23.14069263277926, 2.665144142690225,\r\n        12.98987893203892, 78.23376739376591);\r\n    const vec2 D = vec2(\r\n        1235.6789,\r\n        4378.5453);\r\n    vec2 dotted = M * p;\r\n    vec2 mapped = vec2(cos(dotted.x), sin(dotted.y));\r\n    return fract(mapped * D);\r\n}","unprojectRand":"void unprojectRand(\r\n        inout vec2 randState,\r\n        in vec2 position,\r\n        in mat4 inverseMvp,\r\n        in vec2 inverseResolution,\r\n        in float blur,\r\n        out vec3 from, out vec3 to)\r\n{\r\n    // sample a disk on the near plane (depth of field)\r\n    const float TWOPI = 2.0 * 3.14159265358979323;\r\n    randState = rand(randState);\r\n    float u1 = TWOPI * randState.x;\r\n    float u2 = sqrt(randState.y);\r\n    vec2 offset = vec2(cos(u1), sin(u1)) * u2 * blur;\r\n    vec4 nearPosition = vec4(position + offset, -1.0, 1.0);\r\n\r\n    // sample a square on the far plane (antialiasing)\r\n    randState = rand(randState);\r\n    vec2 antialiasing = (randState * 2.0 - 1.0) * inverseResolution;\r\n    vec4 farPosition = vec4(position + antialiasing, 1.0, 1.0);\r\n\r\n    // map to world space\r\n    vec4 fromDirty = inverseMvp * nearPosition;\r\n    vec4 toDirty = inverseMvp * farPosition;\r\n    from = fromDirty.xyz / fromDirty.w;\r\n    to = toDirty.xyz / toDirty.w;\r\n}","btrand":"float btrand(inout vec4 n) {\r\n    const vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\r\n    const vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\r\n    const vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\r\n    const vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\r\n\r\n    vec4 beta = floor(n / q);\r\n    vec4 p = a * (n - beta * q) - beta * r;\r\n    beta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;\r\n    n = (p + beta);\r\n\r\n    return fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\r\n}","encodeFloat":"highp float shiftRight(highp float v, highp float amt) {\r\n    v = floor(v) + 0.5;\r\n    return floor(v / exp2(amt));\r\n}\r\n\r\nhighp float shiftLeft(highp float v, highp float amt) {\r\n    return floor(v * exp2(amt) + 0.5);\r\n}\r\n\r\nhighp float maskLast(highp float v, highp float bits) {\r\n    return mod(v, shiftLeft(1.0, bits));\r\n}\r\n\r\nhighp float extractBits(highp float num, highp float from, highp float to) {\r\n    from = floor(from + 0.5); to = floor(to + 0.5);\r\n    return maskLast(shiftRight(num, from), to - from);\r\n}\r\n\r\nlowp vec4 encodeFloat(highp float val) {\r\n    if (val == 0.0) {\r\n        return vec4(0.0);\r\n    }\r\n    highp float sgn = val > 0.0 ? 0.0 : 1.0;\r\n    val = abs(val);\r\n    highp float exponent = floor(log2(val));\r\n    highp float biasedExponent = exponent + 127.0;\r\n    highp float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\r\n    highp float t = biasedExponent / 2.0;\r\n    highp float lastBitOfBiasedExponent = fract(t) * 2.0;\r\n    highp float remainingBitsOfBiasedExponent = floor(t);\r\n    highp float byte4 = extractBits(fraction, 0.0, 8.0) / 255.0;\r\n    highp float byte3 = extractBits(fraction, 8.0, 16.0) / 255.0;\r\n    highp float byte2 = (lastBitOfBiasedExponent * 128.0 + extractBits(fraction, 16.0, 23.0)) / 255.0;\r\n    highp float byte1 = (sgn * 128.0 + remainingBitsOfBiasedExponent) / 255.0;\r\n    return vec4(byte4, byte3, byte2, byte1);\r\n}","floatToRgba":"vec4 floatToRgba(float x) {\r\n    const vec4 encoder = vec4(1.0, 255.0, 255.0 * 255.0, 255.0 * 255.0 * 255.0);\r\n    const vec4 corrector = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    vec4 enc = fract(x * encoder);\r\n    return enc - enc.yzww * corrector;\r\n}","hue":"#define HUE_PART 0.16666666666666\r\nvec4 hue(float x) {\r\n    float r = smoothstep(1.0 * HUE_PART, 2.0 * HUE_PART, x) - smoothstep(4.0 * HUE_PART, 5.0 * HUE_PART, x);\r\n    float g = smoothstep(0.0 * HUE_PART, 1.0 * HUE_PART, x) - smoothstep(3.0 * HUE_PART, 4.0 * HUE_PART, x);\r\n    float b = smoothstep(2.0 * HUE_PART, 3.0 * HUE_PART, x) - smoothstep(5.0 * HUE_PART, 6.0 * HUE_PART, x);\r\n    return vec4(1.0 - r, g, b, 1.0);\r\n}","rgbaToFloat":"float rgbaToFloat(vec4 x) {\r\n    const vec4 decoder = 1.0 / vec4(1.0, 255.0, 255.0 * 255.0, 255.0 * 255.0 * 255.0);\r\n    return dot(x, decoder);\r\n}","wang":"uint wang(uint seed) {\r\n    seed = (seed ^ 61) ^ (seed >> 16);\r\n    seed *= 9;\r\n    seed = seed ^ (seed >> 4);\r\n    seed *= 0x27d4eb2d;\r\n    seed = seed ^ (seed >> 15);\r\n    return seed;\r\n}","YUVBT601":"vec3 rgb2yuv(vec3 rgb) {\r\n    const mat3 RGB2YUV = mat3(\r\n         0.29900, -0.14713,  0.61500,\r\n         0.58700, -0.28886, -0.51499,\r\n         0.11400,  0.43600, -0.10001\r\n    );\r\n\r\n    return RGB2YUV * rgb;\r\n}\r\n\r\nvec3 yuv2rgb(vec3 yuv) {\r\n    const mat3 YUV2RGB = mat3(\r\n         1.00000,  1.00000,  1.00000,\r\n         0.00000, -0.39465,  2.03211,\r\n         1.13983, -0.58060,  0.00000\r\n    );\r\n\r\n    return YUV2RGB * yuv;\r\n}","YUVBT709":"vec3 rgb2yuv(vec3 rgb) {\r\n    const mat3 RGB2YUV = mat3(\r\n         0.21260, -0.09991,  0.61500,\r\n         0.71520, -0.33609, -0.55861,\r\n         0.07220,  0.43600, -0.05639\r\n    );\r\n\r\n    return RGB2YUV * rgb;\r\n}\r\n\r\nvec3 yuv2rgb(vec3 yuv) {\r\n    const mat3 YUV2RGB = mat3(\r\n         1.00000,  1.00000,  1.00000,\r\n         0.00000, -0.21482,  2.12798,\r\n         1.28033, -0.38059,  0.00000\r\n    );\r\n\r\n    return YUV2RGB * yuv;\r\n}"}